# Problem 3: Huffman Coding

The provided code implements the Huffman encoding and decoding algorithm, a popular technique for data compression. It builds a Huffman tree based on the frequencies of characters in the input data, encodes the data using the generated tree, and then decodes it. I'll provide explanations and discuss the time and space efficiency for each section of the code.

## Data Structures Used
- **Node Class**: A custom `Node` class is used to represent nodes in the Huffman tree. Each node has attributes for a character (`char`), its frequency (`freq`), and references to left and right child nodes. This class is used for building the Huffman tree.

## Huffman Encoding (Function: `huffman_encoding`)

### Step 1: Build the Huffman Tree
- **Frequency Dictionary**: Initially, a frequency dictionary (`frequencies`) is constructed, which stores the frequency of each character in the input data. This is used to determine the priority for creating nodes in the Huffman tree.
- **Node List**: Nodes are created from the characters and their frequencies and stored in a list (`nodes`).
- **Huffman Tree Construction**: The Huffman tree is constructed iteratively by merging the two nodes with the lowest frequencies and creating a new parent node with the sum of their frequencies. This process continues until there's only one node left in the list, which represents the root of the Huffman tree.

### Step 2: Generate the Encoded Data
- **Encoding Dictionary**: An encoding dictionary (`encoding_dict`) is created to map characters to their Huffman codes. This dictionary is built by traversing the Huffman tree and assigning '0' for a left branch and '1' for a right branch. The `build_encoding_dict` function recursively generates the codes.
- **Encoded Data**: The encoded data is generated by concatenating the Huffman codes for each character in the input data using the `encoding_dict`.

### Time Efficiency for Huffman Encoding
- Building the Huffman tree takes O(N*log(N)) time, where N is the number of unique characters in the input data.
- Generating the encoded data takes O(N) time, where N is the length of the input data.

### Space Efficiency for Huffman Encoding
- The space complexity is determined by the Huffman tree and the encoding dictionary. The Huffman tree uses O(N) space, where N is the number of unique characters, and the encoding dictionary uses O(N) space, as well.

## Huffman Decoding (Function: `huffman_decoding`)

### Step 3: Huffman Decoding
- **Decoded Data**: The decoding process starts with an empty string for `decoded_data` and begins at the root of the Huffman tree.
- **Traversal**: The encoded data is traversed bit by bit. For each '0' bit, the traversal moves to the left child of the current node, and for each '1' bit, it moves to the right child.
- **Character Identification**: When a leaf node (a character node) is reached, its character is appended to the `decoded_data`. The traversal then resets to the root of the tree.
- **Repetition**: This process continues until the entire encoded data is decoded.

### Time Efficiency for Huffman Decoding
- The decoding process takes O(N) time, where N is the length of the encoded data.

### Space Efficiency for Huffman Decoding
- The space efficiency is determined by the size of the `decoded_data`, which uses O(N) space.

In summary, the Huffman encoding and decoding algorithm efficiently compresses and decompresses data by utilizing a Huffman tree. It achieves good time and space efficiency, as demonstrated in the provided test cases.